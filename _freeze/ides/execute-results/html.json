{
  "hash": "33f22f32041f27933f18563ddb10040a",
  "result": {
    "markdown": "# IDEs {#sec-ides}\n\nAs discussed in [Chapter -@sec-environment], coding doesn't happen in a vacuum.\nOne important part of a programmer's workflow is their integrated development\nenvironment, also known as IDE. In short, an IDE provides tools that aid in\nsoftware development, like debuggers, compilers, interpreters, syntax\nhighlighters, and much more.\n\nThe choice of IDE is up to the developer. Some enjoy having more tools at their\ndisposal, while other prefer simplicity and portability. When talking about R,\nthere are four popular choices:\n[RStudio](https://www.rstudio.com/products/rstudio/),\n[VS Code](https://code.visualstudio.com),\n[Emacs](https://www.gnu.org/software/emacs/), and [Neovim](https://neovim.io/).\n\n::: callout-note\n## Note\n\nStrictly speaking, Emacs and Neovim are not fully fledged IDEs, instead being\nclassified as [text editors](https://en.wikipedia.org/wiki/Text_editor) (a\ndifference that will be explained later in the chapter). For the sake of\nsimplicity, I'll be lumping these two together with RStudio and VS Code.\n:::\n\nIn the coming sections I'll talk about each of them, their advantages and\ndisadvantages, as well as a few tips on how to make the most out of their\nfeatures.\n\n## RStudio\n\nRStudio is, by far, the most popular IDE for R. It was first released in 2011\nand is maintained by [RStudio, PBC](https://www.rstudio.com/) (now\n[Posit, PBC](https://posit.co/)), a company whose contribution to the R\ncommunity is hard to overestimate.\n\n\n::: {.cell}\n::: {.cell-output-display}\n![[RStudio](https://en.wikipedia.org/wiki/RStudio#/media/File:RStudio_IDE_screenshot.png) by cdhowe / [CC BY-SA 4.0](https://creativecommons.org/licenses/by-sa/4.0/)](images/rstudio_screenshot.webp)\n:::\n:::\n\n\nUnlike the other software applications featured here, RStudio was made for R.\nFor the majority of its life, it only supported direct code execution and\nextensions associated with the language, e.g., RMarkdown and Shiny. This only\nchanged in the past few years with additional support for Python and Jupyter\nnotebooks through the [reticulate](https://rstudio.github.io/reticulate/)\npackage.\n\n### Pros and cons\n\nGiven its dedication to the R environment, RStudio is probably the easiest to\nuse. There is no setup and no extensions to install; it simply works.\n\nIt's integrated R console allows you to, out of the box, execute code directly.\nThe fact that the interface is so tightly coupled with R means that you get\nfeatures that you basically can't get anywhere else: RMarkdown integration,\nmemory monitoring, database connections, etc.\n\nRStudio is also deeply connected to its company's other products. One of this\nIDEs best features is its web version called RStudio Server; there is a free and\na paid version, but both allow you to basically access a remote server through\nRStudio's interface. This means that you can use the processing power of a\ndifferent machine and access it via the web on your local computer.\n\nAnd I haven't even scratched the surface of RStudio's integrations! There is\nalso [Team](https://www.rstudio.com/products/team/),\n[Workbench](https://www.rstudio.com/products/workbench/),\n[Connect](https://www.rstudio.com/products/connect/) and\n[Package Manager](https://www.rstudio.com/products/package-manager/), enterprise\nsolutions that can be accessed right through the IDE. Last but not least,\n[Shinyapps.io](https://www.rstudio.com/products/shinyapps/), RStudio's Shiny\nhosting solution, gets a dedicated one-click deployment feature on RStudio.\n\nHowever, despite all of these facilities, some people would argue that RStudio\nis lacking in customizability and extensibility. At the time of writing, its\ninterface is stuck as quadrants, each with multiple tabs that you can't close or\nrearrange. The way content is structured is, in general, a little clunky, with a\nlot of space devoted to tools very few people use.\n\nIf you use RStudio for as long as I have, you'll also catch on to a handful of\nminor quality of life issues. Here is a list of a few drawbacks of this IDE that\nadd some friction to one's development workflow:\n\n- The file explorer is slow and hard to use if you want to move more than one\nfile back and forth.\n\n- Sometimes printing large objects makes the console stop responding and, given\nRStudio's intimate connection with its REPL, only by quitting the full\napplication can you stop this kind of process.\n\n- [Diagnostics](https://github.com/rstudio/rstudio/issues/9692) have been\ncluttering local R sessions since 2021, which isn't necessarily a problem, but\nsome novices might think that there is something wrong with their IDE.\n\n- You still can't use multi-core processing via forking with\n[furrr](https://furrr.futureverse.org/) and friends because, at the moment, it\nis considered unstable.\n\n- Again because of its connection to the console, if R encounters a fatal error,\nthen the whole IDE crashes.\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](images/rstudio_bomb_screenshot.webp)\n:::\n:::\n\n\nGetting rid of all of these problems obviously comes at a price that most people\naren't willing to pay. RStudio's ease of use is a big advantage for the majority\nof R programmers.\n\n### Tips\n\nAs explained before, RStudio is the most plug and play of all four IDEs and, if\nyou decide to use it, there is very little you can do to improve it. This\ndoesn't mean, however, that you should use it with _all_ of its factory\ndefaults. Most notably, RStudio comes out of the box with the REPL console below\nthe file editor, which is not most peoples' preference. In order to change this,\nclick the windowed button at the top of the interface and select\n**Console on Left**. You'll thank me later.\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](images/rstudio_panes_screenshot.webp)\n:::\n:::\n\n\nIf you are a person with particular concerns about the reproducibility of your\nanalyses, I suggest you also change another setting in RStudio: turn off\nautomatic `.RData` saving.\n\nIf you don't know what this hidden file is, it basically stores the data you use\n(also called your workspace) during a coding session. While this seems very\nconvenient, it disincentivizes writing reproducible and resilient code. Don't\nbelieve me? Here is the description of `usethis::use_blank_slate()` a function\n(made by the very people at RStudio!) that disables `.RData`:\n\n> [...] However, long-term reproducibility is enhanced when you turn this\n> feature off and clear R's memory at every restart. Starting with a blank slate\n> provides timely feedback that encourages the development of scripts that are\n> complete and self-contained. [...]\n\nIf you don't want to use `usethis::use_blank_slate()`, you can also change this\nsetting manually in RStudio. In **Tools > Global Optionsâ€¦**, turn off\n**Restore .RData** and **Always save history**; additionally, set\n**Save workspace** to \"never\".\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](images/rstudio_settings_screenshot.webp)\n:::\n:::\n\n\n## VS Code\n\nVisual Studio Code, also known as VS Code, is the new kid on the block. Released\nby Microsoft in 2015, it quickly became the most popular code editor in the\nworld: it went from being used by 7% of developers in 2016[^1] to 74% by\n2022[^2].\n\n[^1]: [StackOverflow Developer Survey 2016](https://insights.stackoverflow.com/survey/2016#technology-development-environments)\n\n[^2]: [StackOverflow Developer Survey 2022](https://survey.stackoverflow.co/2022/#section-most-popular-technologies-integrated-development-environment)\n\n\n::: {.cell}\n::: {.cell-output-display}\n![[R in Visual Studio Code](https://code.visualstudio.com/docs/languages/r)](images/vscode_screenshot.webp)\n:::\n:::\n\n\nWhen compared to RStudio, VS Code is much less plug and play. By default it\ndoesn't come bundled with tools for programming in R and you might have to learn\nsome shortcuts, but it does have its benefits. So much so that RStudio Workbench\nallows you to choose between their own IDE and VS Code when creating a new\nproject.\n\n### Pros and cons\n\nIn my opinion, the biggest argument in favor of using VS Code is its\nflexibility. You can \"pop the hood\" of the IDE and edit every minute setting of\nits interface, creating new shortcuts and snippets, editing the configuration\nfiles directly, and even create extensions that enhance your development\nworkflow.\n\nUnlike RStudio's addins, VS Code's extensions can profoundly alter your\ndevelopment environment. There is an\n[extension marketplace](https://marketplace.visualstudio.com/vscode) through\nwhich you can download anything from aesthetic themes to debuggers, from spell\ncheckers to support for additional languages. While I'm writing this very\nsentence, I have multiple extensions working on the background: one to\nautomatically format paragraphs to my desired line width, one to fix my spelling\nmistakes, and one for [Quarto](https://quarto.org/) code completion (made by\nRStudio!).\n\nVS Code's interface is also extremely flexible. Text files, R consoles, terminal\nemulators, plot viewers, and web browsers (e.g. Shiny preview windows) are all\ntabs that can be arranged however you like. On the left side you also get a\npowerful file explorer and shortcuts an integrated git client, a global search\ntool, and every extension you choose to pin (e.g. R's workspace viewer).\n\nI personally chose VS Code as my daily driver, but it is not without its flaws.\nFirst and foremost, it does not come with R support out of the box and it is up\nto each individual developer to install the necessary extensions to make it\nwork. There is an official\n[tutorial](https://code.visualstudio.com/docs/languages/r), but, in order to get\nthe most out of VS Code, you really must follow the extra steps described at the\nend of the **Getting Started** section; this will, however, involve installing\na new R console through Python and editing your `.Rprofile`.\n\nUnlike RStudio, VS Code's R console is not integrated to the rest of the IDE.\nThis solves the issues with multi-core processing and full crases, but it\ncreates other problems; for one, you have to start the R console every time you\nopen VS Code, which can get boring pretty fast. The plot viewer is also a little\nclunky, so you have to be smart with your window management if you don't want\ngigantic plots taking up half of your screen.\n\nTo sum up, VS Code is a modern and customizable IDE that can work with any\nlanguage you can imagine. This wholistic approach means that you get really cool\nfeatures, but also that you loose some tighter integrations which RStudio alone\ncan offer.\n\n### Tips\n\nAs alluded to above, you should follow VS Code's tutorial on how to setup\nsupport for R. Make sure to read the full instructions for your operating\nsystem because they are different for each OS\n([Windows](https://github.com/REditorSupport/vscode-R/wiki/Installation:-Windows),\n[macOS](https://github.com/REditorSupport/vscode-R/wiki/Installation:-macOS),\nand [Linux](https://github.com/REditorSupport/vscode-R/wiki/Installation:-Linux))!\n\nYou might also want to configure some settings and shortcuts; this is not\ntrivial, but it will help with some minor hiccups for R users. First, open your\n**Command Palette** with `Ctrl+Shift+P` (`Cmd+Shift+P` on Mac) and select the\n**Preferences: Open User Settings (JSON)** command. Your `settings.json` should\nopen and I suggest you replaces its contents with the following, making sure not\nto remove the settings you have already added during radian's setup:\n\n```json\n{\n    \"editor.minimap.enabled\": false,\n    \"workbench.startupEditor\": \"none\",\n    \"editor.tabSize\": 2,\n    \"files.defaultLanguage\": \"r\",\n    \"terminal.integrated.defaultLocation\": \"editor\",\n    \"diffEditor.ignoreTrimWhitespace\": false,\n    \"files.trimTrailingWhitespace\": true,\n    \"editor.rulers\": 80,\n\n    // Radian setup! Keep yours as is!\n    \"r.rterm.mac\": \"/opt/homebrew/bin/radian\",\n    \"r.bracketedPaste\": true,\n}\n```\n\nOn the **Command Palette** again, select the\n**Preferences: Open Keyboards Shortcut (JSON)** command. It will open a file\nwhere you can define some shortcuts that you like. Mine looks like this (make\nsure to swap `cmd` with `ctrl` wherever necessary):\n\n```json\n[\n    {\n        \"key\": \"cmd+shift+m\",\n        \"command\": \"type\",\n        \"args\": { \"text\": \" |>\" },\n        \"when\": \"editorTextFocus && editorLangId == 'r'\"\n    },\n    {\n        \"key\": \"alt+-\",\n        \"command\": \"type\",\n        \"args\": { \"text\": \" <- \" },\n        \"when\": \"editorTextFocus && editorLangId == 'r'\"\n    },\n    {\n        \"key\": \"shift+cmd+l\",\n        \"command\": \"r.loadAll\"\n    },\n]\n```\n\n## Emacs\n\nEmacs (short for \"Editor MACroS\") is not a single text editor, but in fact a\nfamily of them. There are many Emacs _variants_, as they're called, but the one\nI'm going to talk about is [GNU Emacs](https://www.gnu.org/software/emacs/),\nwhich was released in 1985 and is to this day the most common implementation of\nEmacs.\n\n\n::: {.cell}\n::: {.cell-output-display}\n![[Emacs running ESS](https://github.com/ess-intro/presentation-ess-customization/blob/main/tutorial/images/window_config.png)](images/emacs_screenshot.webp)\n:::\n:::\n\n\nThis software is old, let's get that out of the way, but it doesn't mean that\nit's not good. Emacs is still being actively developed and has a devoted\ncommunity of users that swear by its superiority over all other text editors.\n\n### Pros and cons\n\nIn the section above, when talking about VS Code, I described it as extensible.\nEmacs is off the charts. People who don't like Emacs\n[say](https://en.wikipedia.org/wiki/Editor_war#Humor) that it is \"a great\noperating system, lacking only a decent editor\". You can add so much stuff to it\nthat it becomes barely recognizable.\n\nThis is both a pro and a con. You can configure your Emacs to your heart's\ncontent, but this also means that it can get pretty hard to get help online when\nsomething breaks. If you decide to try out Emacs, first you must decide how much\nyou like to tinker with obscure settings and arcane Lisp.\n\nLike VS Code, Emacs needs an add-on in order to support R. This add-on, called\n[_Emacs Speaks Statistics_](https://ess.r-project.org/) (ESS), allows you to use\nEmacs much like you would RStudio: it has a file editor, a console, a\ndocumentation pane, and a environment explorer. The connection between the\ninterface and the R process, however, is not as tightly coupled as RStudio's; in\nEmacs you don't have to worry about crashing the whole program if you do\nsomething wrong inside R.\n\nOverall, Emacs is light, widely supported, customizable, and solid. It is not,\nhowever, simple. For example, Emacs has a strong reliance on modifier keys,\nmeaning that every shortcuts must be prepended by `Escape`, `Meta`, `Alt`,\n`Control`, and/or `Shift`; this phenomenon is so prevalent that people coined a\nspecific term for RSI caused by using your pinky finger to access modifier keys\ntoo often: [Emacs pinky](https://en.wikipedia.org/wiki/Emacs#Emacs_pinky).\n\nBelow you'll find a short example (adapted from\n[here](https://ess.r-project.org/Manual/ess.html#Example-ESS-usage)) of how one\ncan use ESS to analyze some data. Note that every `C-` and `M-` is short for\n`Ctrl+` and `Meta+`.\n\n```txt\n### Data Analysis Example\n\n## Open the file you want\nC-x C-f myfile.R\n\n## Edit as appropriate, then start and switch to an *R*\n## process buffer\nC-c C-z\n\n## A new buffer *R* will appear. R will have been started\n## in this buffer. The buffer is in iESS [R] mode.\n\n## Return to the script\nC-z\n\n## Send current region (if active), or function, or\n## paragraph at point\nC-M-x\n\n## Send current region or function or paragraph and step\nC-c C-c\n\n## Send current line\nC-RET\n\n## Or load the entire buffer\nC-c C-l\n\n## Save the revised myfile.R\nC-x C-s.\n\n## Save the entire *R* interaction buffer\nC-x C-s.\n\n## Search for documentation\nC-c C-d\n\n## Investigate available ESS commands\nC-c C-h\n```\n\nYet, people still love Emacs. The fact that you can still pick up a tutorial\nfrom the 90's and have it still work is just plain awesome. Emacs' mix of\nreliability and extensibility makes for an intoxicating brew.\n\n### Tips\n\nThe first thing you'll want to do in order to learn how to use Emacs and ESS is\nread [ESS Intro's](https://github.com/ess-intro) tutorials. They have a\ncollection of [presentations](https://ess-intro.github.io/) and\n[YouTube videos](https://www.youtube.com/channel/UCph8LPTQ8gkNnKf1WHF2Tgg) that\nhelp you get started with R in Emacs. They even have an\n[introduction](https://www.youtube.com/watch?v=1YOrd7NCGkg) to Emacs itself\nwhich might come in handy for the uninitiated.\n\nAnother aspect of Emacs that might interest you is the distributions that try to\nget rid of the flood of modifier keys that most users have to deal with.\n[Doom Emacs](https://github.com/doomemacs/doomemacs) and\n[Spacemacs](https://github.com/syl20bnr/spacemacs) are two noteworthy\ninitiatives.\n\n\n::: {.cell}\n::: {.cell-output-display}\n![[Doom Emacs](https://github.com/doomemacs/doomemacs/tree/screenshots#emacsd-screenshots)](images/doom_screenshot.webp)\n:::\n:::\n\n\nThese more modern \"alternatives\" use Vim keybindings (which will be discussed\nbelow) and substitute modifier keys with combinations of other keys that are\neasier to access. They also come packed with presets that most users will want\nto configure anyway, cutting a lot of the setup out of the learning process.\n\n## Neovim\n\nNeovim is the successor to\n[Vim](https://en.wikipedia.org/wiki/Vim_(text_editor)) (which is itself a\nsuccessor to [vi](https://en.wikipedia.org/wiki/Vi)). Launched in 2015, it\nattempts to fix the problems found in its predecessors, reinvigorating vi's side\nin the [editor war](https://en.wikipedia.org/wiki/Editor_war).\n\n\n::: {.cell}\n::: {.cell-output-display}\n![[Neovim running Nvim-R](https://github.com/jalvesaq/Nvim-R)](images/nvim_screenshot.webp)\n:::\n:::\n\n\nAgain, like VS Code and Emacs, support for R in Neovim is dependent on plugins\nthat extend its functionalities. This is for sure the most bare-bones of all\neditors discussed here, but you'll for sure look like a hacker while using it.\n\n### Pros and cons\n\nvi was launched in 1976, the same year as Emacs. It has gone through many\nversions and iterations, arriving in its current form only a few years ago, but\nthis doesn't mean that it isn't robust or solid. Most of the changes from Vim to\nNeovim happened in the plugin and configuration systems; most shortcuts and\nfunctionalities remain the same since 1991.\n\nWhile not as extensible as Emacs, Neovim also has a vibrant add-in ecosystem.\n[Nvim-R](https://github.com/jalvesaq/Nvim-R) is the plugin that enables R\nsupport on the editor and it works basically in the same way as all other\nextensions discussed in this chapter: it adds a console, a documentation viewer,\nand a environment explorer to the standard file editor.\n\nAs one can probably tell from the image above, Neovim runs on the terminal. It\nis the lightest and fastest of all four editors, working perfectly via SSH\nconnections and on slower machines.\n\nNeovim's downsides mostly stem from its focus on minimalism. Unlike Emacs, which\nuses modifier keys to access shortcuts, Neovim uses something called modes. In\nits default mode, every key on the keyboard has a special meaning and can be\ncombined with other keys to create complex and powerful commands. In order to\nactually edit the file, you must use the `i` key and enter \"insert mode\".\n\nMost of the time, users are constantly switching from mode to mode and taking\nadvantage of its many, many keybindings. While this strategy is easier on the\nfingers than Emacs' modifiers, it has a significantly shallower learning curve.\nA common joke among novices is that it's easier to turn off your computer than\nquit Vim/Neovim[^3].\n\nHow much speed and memory usage matters is up to the individual developer.\nNeovim might be hard to get into, but most users argue that the productivity\ngain from its keybindings is worth the hassle.\n\n[^3]: The shortcut to quit Vim/Neovim is `:wq`.\n\n### Tips\n\nOf all four applications, Neovim is probably the least common when talking about\nR development. There isn't much online that can help you with Nvim-R besides the\n[official documentation](https://github.com/jamespeapen/Nvim-R/wiki). Just make\nsure you have\n[installed](https://github.com/neovim/neovim/wiki/Installing-Neovim) Neovim\ncorrectly first!\n\nA really useful thing to do before jumping into Neovim is learning the\nkeybindings with [Vim Adventures](https://vim-adventures.com/). There are also\nmany [cheat sheets](https://vim.rtorr.com/) that can help in the process.\nRemember that almost all commands are the same in both Neovim and Vim, so you\nmight find better online documentation when searching for \"vim\" instead of\n\"neovim\".\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}