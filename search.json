[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Beautiful R",
    "section": "",
    "text": "Preface\nIf you came here of your own volition, you’re probably an R programmer. Maybe you’re still a novice, maybe you’ve already had your fair share of cannot coerce type 'closure' errors; either way, you’re trying to grapple with this (at the time of writing) almost thirty years-old programming language.\nIt’s tough, I know. Take a deep breath. I’ve got you covered.\nBeautiful R is a book about what R does right: its goal is to both help you succeed at programming R, and showcase this quirky little language’s full potential. Think of it as the antithesis to The R Inferno.\nThe book is divided into three sections in increasing order of complexity:\n\nStructure explains how to create and use R projects effectively. Learn how to setup your environment, use code editors responsibly, and never lose a file again.\nPatterns is full of tips on programming R well. Transform your projects into packages, avoid silly mistakes by creating unit tests, and learn how to write good R code.\nStyle covers the last step in the ladder: making your code clean, easy to understand, and beautiful. Once you are able to consistently write good code, it’s time to start writing great code."
  },
  {
    "objectID": "introduction.html",
    "href": "introduction.html",
    "title": "Introduction",
    "section": "",
    "text": "R is wabi-sabi."
  },
  {
    "objectID": "structure.html",
    "href": "structure.html",
    "title": "Structure",
    "section": "",
    "text": "List packages to install."
  },
  {
    "objectID": "environment.html#file-system",
    "href": "environment.html#file-system",
    "title": "1  Environment",
    "section": "1.1 File system",
    "text": "1.1 File system\nIn Chapter 3, we’ll discuss how to organize an R project, but first we need some guidelines on how to organize files in general. Many people underestimate the usefulness organizing and naming their files consistently, but the truth is that having a system saves you valuable time when searching through your past projects.\nFirst of all, I suggest you create a folder in your computer for all your programming needs. It’s not that rare to create a lot of files when coding, and making sure they will all be in a single place really helps. Since scripts are able to write and delete files, this lowers the odds that an R program ruins your valuable personal files by accident.\nNow for the files. Danielle Navarro has an amazing presentation about project structure where she outlines three main principles to go by when naming files:\n\nBe nice to machines.\nBe nice to humans.\nMake sorting and searching easy.\n\n\n1.1.1 Be nice to machines\nMachines usually get confused by spaces, special characters (like ^.*?+|$\"), and accents. Some operating systems also treat uppercase and lowercase as the same. Our files should, therefore, always separate words with _ or - (consistently), only use lowercase letters and numbers, and never use accented characters.\n# Good\ndraft01_jalapeno_essay.docx\n\n# Bad\nDraft \"Jalapeño\" Essay(1).docx\nAn important exception here are file extensions: R scripts should be terminated by .R, always uppercase. This is a longstanding tradition, so it takes precedence over the other rules.\n\n\n1.1.2 Be nice to humans\nHumans need context, so short and vague file names are to be avoided. A good practice is to begin the file name with its “type” (e.g. analysis, note, report, etc.) and then append a meaningful description.\n# Good\nanalysis01_descriptive-statistics.R\nnotes02_tentative-write-up.docx\n\n# Bad\n01.R\nnotes2.docx\nNote how, in the examples above, - is used to separate words that belong to the same “chunk”, and _ is used to separate different “chunks”. I don’t follow this suggestion personally, but many people like the idea.\n\n\n1.1.3 Make sorting and searching easy\nIf your files names need to include dates, always follow the YYYY-MM-DD format and place them before the description so that the files are sorted automatically.\n# Good\n2012-01-01.R\n2012-01-02.R\n2012-04-01.R\n\n# Bad\n1-April-2012.R\n1-Jan-2012.R\n2-Jan-2012.R\nIf you need to order files by something other than date, use numbers as prefix, but remember to left pad with 0 so that all numbers have the same length. Also include keywords if you want to divide files by type.\n# Good\nreading01_shakespeare_romeo-and-juliet.docx\nreading02_shakespeare_romeo-and-juliet.docx\n...\nreading11_shakespeare_romeo-and-juliet.docx\nnotes01_shakespeare_romeo-and-juliet.docx\n..."
  },
  {
    "objectID": "environment.html#profile",
    "href": "environment.html#profile",
    "title": "1  Environment",
    "section": "1.2 Profile",
    "text": "1.2 Profile\nMost users don’t know about a little file called .Rprofile (the dot at the beginning makes the file invisible). Your .Rprofile contains R code that is run every time you open R, so this is a good place to set some options and configurations. It’s also an amazing place to make your analyses impossible to reproduce.\nIf you’ve never used this feature of R, I suggest you stay this way until you are a seasoned veteran in the language. A good tip for using your .Rprofile correctly is to never put anything that you would write in a script there.\nHere is a good example of an .Rprofile:\n\n# Set repo\noptions(repos = c(CRAN = \"https://cran.rstudio.org\"))\n\n# Change width (like in the beginning of the chapter)\nif (interactive()) {\n  options(width = 10)\n}\n\nIf you really want to add something to your .Rprofile, you can install the usethis package and run usethis::edit_r_profile()."
  },
  {
    "objectID": "environment.html#versions",
    "href": "environment.html#versions",
    "title": "1  Environment",
    "section": "1.3 Versions",
    "text": "1.3 Versions\nTo me, this is the most important part of the chapter. You can fix all of your file names and remove everything from your .Rprofile; if you don’t update your system, it’s all for naught.\nR is a relatively old language, so it has been updated many times since its launch. Every two to three months, the R Core Team releases a new version with many improvements and bug fixes. These updates can be very minor, but sometimes there are truly exciting new features. in R 4.1.0, for example, the native pipe (|>) was introduced, pretty much retiring magrittr.\nThis means that, if you don’t upgrade your R installation, you’ll be missing out on the evolution of the language and leaving your system vulnerable to known bugs.\nThe same is true for packages, the life and blood of R. Packages change much more and much faster than R itself, since they’re not always worried about backwards compatibility. If you leave your packages to rot, expect your scripts to stop working on other peoples’ machines, to have harder time googling bugs, and to get stuck with old code.\nMy advice is then the following:\n\nEvery few weeks make sure to run update.packages() to update your packages.\nEvery few months you should also update the language. If you’re on Windows you can use the installr package, otherwise you can go to their website and grab the newest binary.\n\nIt’s evidently a bit harder to keep your environment up to date than to just keep it unchanged forever. Sometimes you’ll have to rewrite something that stopped working from one version to the next, but this is much easier than letting your system grow more and more out of date until, all of the sudden, everything stops working all at once. If you keep up with every release, the adjustments will be small and frequent; if you don’t, the adjustments will be major and you might not be able to make them in a reasonable amount of time.\nAs a last suggestion, also make sure to update your operating system. R doesn’t support every version of Windows and Mac forever, and I’m not even mentioning the security patches you’re missing when you choose to “update later”."
  },
  {
    "objectID": "editors.html#rstudio",
    "href": "editors.html#rstudio",
    "title": "2  Editors",
    "section": "2.1 RStudio",
    "text": "2.1 RStudio\nRStudio is, by far, the most popular editor for R. It was first released in 2011 and is maintained by RStudio, PBC (now Posit, PBC), a company whose contribution to the R community is hard to overestimate.\n\n\n\n\n\nRStudio by cdhowe / CC BY-SA 4.0\n\n\n\n\nUnlike the other software applications featured here, RStudio was made for R and can be considered a full Integrated Development Environment (IDE). For the majority of its life, it only supported direct code execution and extensions associated with the language, e.g., RMarkdown and Shiny. This only changed in the past few years with additional support for Python and Jupyter notebooks through the reticulate package.\n\n2.1.1 Pros and cons\nGiven its dedication to the R environment, RStudio is probably the easiest to use. There is no setup and no extensions to install; it simply works.\nIts integrated R console allows you to, out of the box, execute code directly. The fact that the interface is so tightly coupled with R means that you get features that you basically can’t get anywhere else: RMarkdown integration, memory monitoring, database connections, etc.\nRStudio is also deeply connected to its company’s other products. One of this IDE’s best features is its web version called RStudio Server; there is a free and a paid version, but both allow you to basically access a remote server through RStudio’s interface. This means that you can use the processing power of a different machine and access it via the web on your local computer.\nAnd I haven’t even scratched the surface of RStudio’s integrations! There is also Team, Workbench, Connect and Package Manager, enterprise solutions that can be accessed right through the IDE. Last but not least, Shinyapps.io, RStudio’s Shiny hosting solution, gets a dedicated one-click deployment feature on RStudio.\nHowever, despite all of these facilities, some people would argue that RStudio is lacking in customizability and extensibility. At the time of writing, its interface is stuck as quadrants, each with multiple tabs that you can’t close or rearrange. The way content is structured is, in general, a little clunky, with a lot of space devoted to tools very few people use.\nIf you use RStudio for as long as I have, you’ll also catch on to a handful of minor quality of life issues. Here is a list of a few drawbacks of this IDE that add some friction to one’s development workflow:\n\nThe file explorer is slow and hard to use if you want to move more than one file back and forth.\nSometimes printing large objects makes the console stop responding and, given RStudio’s intimate connection with its REPL, only by quitting the full application can you stop this kind of process.\nDiagnostics have been cluttering local R sessions since 2021, which isn’t necessarily a problem, but some novices might think that there is something wrong with their IDE.\nYou still can’t use multi-core processing via forking with furrr and friends because, at the moment, it is considered unstable.\nAgain because of its connection to the console, if R encounters a fatal error, then the whole IDE crashes.\n\n\n\n\n\n\nGetting rid of all of these problems obviously comes at a price that most people aren’t willing to pay. RStudio’s ease of use is a big advantage for the majority of R programmers.\n\n\n2.1.2 Tips\nAs explained before, RStudio is the most plug and play of all four editors and, if you decide to use it, there is very little you can do to improve it. This doesn’t mean, however, that you should use it with all of its factory defaults. Most notably, RStudio comes out of the box with the REPL console below the file editor, which is not most peoples’ preference. In order to change this, click the windowed button at the top of the interface and select Console on Left. You’ll thank me later.\n\n\n\n\n\nIf you are a person with particular concerns about the reproducibility of your analyses, I suggest you also change another setting in RStudio: turn off automatic .RData saving.\nIf you don’t know what this hidden file is, it basically stores the data you use (also called your workspace) during a coding session. While this seems very convenient, it disincentivizes writing reproducible and resilient code. Don’t believe me? Here is the description of usethis::use_blank_slate() a function (made by the very people at RStudio!) that disables .RData:\n\n[…] However, long-term reproducibility is enhanced when you turn this feature off and clear R’s memory at every restart. Starting with a blank slate provides timely feedback that encourages the development of scripts that are complete and self-contained. […]\n\nIf you don’t want to use usethis::use_blank_slate(), you can also change this setting manually in RStudio. In Tools > Global Options…, turn off Restore .RData and Always save history; additionally, set Save workspace to “never”.\n\n\n\n\n\n\n\n\n\n\n\nImportant\n\n\n\nIf you’re a beginner in the world of R, you’re welcome to stop this chapter here and come back when you have a couple years experience. RStudio is the best editor for novices and the other options might actually make it harder for you to learn R."
  },
  {
    "objectID": "editors.html#vs-code",
    "href": "editors.html#vs-code",
    "title": "2  Editors",
    "section": "2.2 VS Code",
    "text": "2.2 VS Code\nVisual Studio Code, also known as VS Code, is the new kid on the block. Released by Microsoft in 2015, it quickly became the most popular code editor in the world: it went from being used by 7% of developers in 20161 to 74% by 20222.\n\n\n\n\n\nR in Visual Studio Code\n\n\n\n\nWhen compared to RStudio, VS Code is much less plug and play. By default it doesn’t come bundled with tools for programming in R and you might have to learn some shortcuts, but it does have its benefits. So much so that RStudio Workbench allows you to choose between their own IDE and VS Code when creating a new project.\n\n2.2.1 Pros and cons\nIn my opinion, the biggest argument in favor of using VS Code is its flexibility. You can “pop the hood” of the editor and edit every minute setting of its interface, creating new shortcuts and snippets, editing the configuration files directly, and even create extensions that enhance your development workflow.\nUnlike RStudio’s addins, VS Code’s extensions can profoundly alter your development environment. There is an extension marketplace through which you can download anything from aesthetic themes to debuggers, from spell checkers to support for additional languages. While I’m writing this very sentence, I have multiple extensions working on the background: one to automatically format paragraphs to my desired line width, one to fix my spelling mistakes, and one for Quarto code completion (made by RStudio!).\nVS Code’s interface is also extremely flexible. Text files, R consoles, terminal emulators, plot viewers, and web browsers (e.g. Shiny preview windows) are all tabs that can be arranged however you like. On the left side you also get a powerful file explorer and shortcuts an integrated git client, a global search tool, and every extension you choose to pin (e.g. R’s workspace viewer).\nI personally chose VS Code as my daily driver, but it is not without its flaws. First and foremost, it does not come with R support out of the box and it is up to each individual developer to install the necessary extensions to make it work. There is an official tutorial, but, in order to get the most out of VS Code, you really must follow the extra steps described at the end of the Getting Started section; this will, however, involve installing a new R console through Python and editing your .Rprofile.\nUnlike RStudio, VS Code’s R console is not integrated to the rest of the editor. This solves the issues with multi-core processing and full crases, but it creates other problems; for one, you have to start the R console every time you open VS Code, which can get boring pretty fast. The plot viewer is also a little clunky, so you have to be smart with your window management if you don’t want gigantic plots taking up half of your screen.\nTo sum up, VS Code is a modern and customizable editor that can work with any language you can imagine. This wholistic approach means that you get really cool features, but also that you lose some tighter integrations which RStudio alone can offer.\n\n\n2.2.2 Tips\nAs alluded to above, you should follow VS Code’s tutorial on how to setup support for R. Make sure to read the full instructions for your operating system because they are different for each OS (Windows, macOS, and Linux)!\nYou might also want to configure some settings and shortcuts; this is not trivial, but it will help with some minor hiccups for R users. First, open your Command Palette with Ctrl+Shift+P (Cmd+Shift+P on Mac) and select the Preferences: Open User Settings (JSON) command. Your settings.json should open and I suggest you replace its contents with the following, making sure not to remove the settings you have already added during radian’s setup:\n{\n    \"editor.minimap.enabled\": false,\n    \"workbench.startupEditor\": \"none\",\n    \"editor.tabSize\": 2,\n    \"files.defaultLanguage\": \"r\",\n    \"terminal.integrated.defaultLocation\": \"editor\",\n    \"diffEditor.ignoreTrimWhitespace\": false,\n    \"files.trimTrailingWhitespace\": true,\n    \"editor.rulers\": 80,\n\n    // Radian setup! Keep yours as is!\n    \"r.rterm.mac\": \"/opt/homebrew/bin/radian\",\n    \"r.bracketedPaste\": true,\n    \"r.plot.useHttpgd\": true\n}\nOn the Command Palette again, select the Preferences: Open Keyboards Shortcut (JSON) command. It will open a file where you can define some shortcuts that you like. Mine looks like this (make sure to swap cmd with ctrl wherever necessary):\n[\n    {\n        \"key\": \"cmd+shift+m\",\n        \"command\": \"type\",\n        \"args\": { \"text\": \" |>\" },\n        \"when\": \"editorTextFocus && editorLangId == 'r'\"\n    },\n    {\n        \"key\": \"alt+-\",\n        \"command\": \"type\",\n        \"args\": { \"text\": \" <- \" },\n        \"when\": \"editorTextFocus && editorLangId == 'r'\"\n    },\n    {\n        \"key\": \"shift+cmd+l\",\n        \"command\": \"r.loadAll\"\n    }\n]"
  },
  {
    "objectID": "editors.html#emacs",
    "href": "editors.html#emacs",
    "title": "2  Editors",
    "section": "2.3 Emacs",
    "text": "2.3 Emacs\nEmacs (short for “Editor MACroS”) is not a single text editor, but in fact a family of them. There are many Emacs variants, as they’re called, but the one I’m going to talk about is GNU Emacs, which was released in 1985 and is to this day the most common implementation of Emacs.\n\n\n\n\n\nEmacs running ESS\n\n\n\n\nThis software is old, let’s get that out of the way, but it doesn’t mean that it’s not good. Emacs is still being actively developed and has a devoted community of users that swear by its superiority over all other text editors.\n\n2.3.1 Pros and cons\nIn the section above, when talking about VS Code, I described it as extensible. Emacs is off the charts. People who don’t like Emacs say that it is “a great operating system, lacking only a decent editor”. You can add so much stuff to it that it becomes barely recognizable.\nThis is both a pro and a con. You can configure your Emacs to your heart’s content, but this also means that it can get pretty hard to get help online when something breaks. If you decide to try out Emacs, first you must decide how much you like to tinker with obscure settings and arcane Lisp.\nLike VS Code, Emacs needs an add-on in order to support R. This add-on, called Emacs Speaks Statistics (ESS), allows you to use Emacs much like you would RStudio: it has a file editor, a console, a documentation pane, and an environment explorer. The connection between the interface and the R process, however, is not as tightly coupled as RStudio’s; in Emacs you don’t have to worry about crashing the whole program if you do something wrong inside R.\nOverall, Emacs is light, widely supported, customizable, and solid. It is not, however, simple. For example, Emacs has a strong reliance on modifier keys, meaning that every shortcut must be prepended by Escape, Meta, Alt, Control, and/or Shift; this phenomenon is so prevalent that people coined a specific term for RSI caused by using your pinky finger to access modifier keys too often: Emacs pinky.\nBelow you’ll find a short example (adapted from here) of how one can use ESS to analyze some data. Note that every C- and M- is short for Ctrl+ and Meta+.\n### Data Analysis Example\n\n## Open the file you want\nC-x C-f myfile.R\n\n## Edit as appropriate, then start and switch to an *R*\n## process buffer\nC-c C-z\n\n## A new buffer *R* will appear. R will have been started\n## in this buffer. The buffer is in iESS [R] mode.\n\n## Return to the script\nC-z\n\n## Send current region (if active), or function, or\n## paragraph at point\nC-M-x\n\n## Send current region or function or paragraph and step\nC-c C-c\n\n## Send current line\nC-RET\n\n## Or load the entire buffer\nC-c C-l\n\n## Save the revised myfile.R\nC-x C-s.\n\n## Save the entire *R* interaction buffer\nC-x C-s.\n\n## Search for documentation\nC-c C-d\n\n## Investigate available ESS commands\nC-c C-h\nYet, people still love Emacs. The fact that you can still pick up a tutorial from the 90’s and have it still work is just plain awesome. Emacs’ mix of reliability and extensibility makes for an intoxicating brew.\n\n\n2.3.2 Tips\nThe first thing you’ll want to do in order to learn how to use Emacs and ESS is read ESS Intro’s tutorials. They have a collection of presentations and YouTube videos that help you get started with R in Emacs. They even have an introduction to Emacs itself which might come in handy for the uninitiated.\nAnother aspect of Emacs that might interest you is the distributions that try to get rid of the flood of modifier keys that most users have to deal with. Doom Emacs and Spacemacs are two noteworthy initiatives.\n\n\n\n\n\nDoom Emacs\n\n\n\n\nThese more modern “alternatives” use Vim keybindings (which will be discussed below) and substitute modifier keys with combinations of other keys that are easier to access. They also come packed with presets that most users will want to configure anyway, cutting a lot of the setup out of the learning process."
  },
  {
    "objectID": "editors.html#neovim",
    "href": "editors.html#neovim",
    "title": "2  Editors",
    "section": "2.4 Neovim",
    "text": "2.4 Neovim\nNeovim is the successor to Vim (which is itself a successor to vi). Launched in 2015, it attempts to fix the problems found in its predecessors, reinvigorating vi’s side in the editor war.\n\n\n\n\n\nNeovim running Nvim-R\n\n\n\n\nAgain, like VS Code and Emacs, support for R in Neovim is dependent on plugins that extend its functionalities. This is for sure the most bare-bones of all editors discussed here, but you’ll for sure look like a hacker while using it.\n\n2.4.1 Pros and cons\nvi was launched in 1976, the same year as Emacs. It has gone through many versions and iterations, arriving in its current form only a few years ago, but this doesn’t mean that it isn’t robust or solid. Most of the changes from Vim to Neovim happened in the plugin and configuration systems; most shortcuts and functionalities remain the same since 1991.\nWhile not as extensible as Emacs, Neovim also has a vibrant add-in ecosystem. Nvim-R is the plugin that enables R support on the editor and it works basically in the same way as all other extensions discussed in this chapter: it adds a console, a documentation viewer, and a environment explorer to the standard file editor.\nAs one can probably tell from the image above, Neovim runs on the terminal. It is the lightest and fastest of all four editors, working perfectly via SSH connections and on slower machines.\nNeovim’s downsides mostly stem from its focus on minimalism. Unlike Emacs, which uses modifier keys to access shortcuts, Neovim uses something called modes. In its default mode, every key on the keyboard has a special meaning and can be combined with other keys to create complex and powerful commands. In order to actually edit the file, you must use the i key and enter “insert mode”.\nMost of the time, users are constantly switching from mode to mode and taking advantage of its many, many keybindings. While this strategy is easier on the fingers than Emacs’ modifiers, it has a significantly shallower learning curve. A common joke among novices is that it’s easier to turn off your computer than quit Vim/Neovim3.\nHow much speed and memory usage matters is up to the individual developer. Neovim might be hard to get into, but most users argue that the productivity gain from its keybindings is worth the hassle.\n\n\n2.4.2 Tips\nOf all four applications, Neovim is probably the least common when talking about R development. There isn’t much online that can help you with Nvim-R besides the official documentation. Just make sure you have installed Neovim correctly first!\nA really useful thing to do before jumping into Neovim is learning the keybindings with Vim Adventures. There are also many cheat sheets that can help in the process. Remember that almost all commands are the same in both Neovim and Vim, so you might find better online documentation when searching for “vim” instead of “neovim”."
  },
  {
    "objectID": "r-projects.html#paths-absolute-and-relative",
    "href": "r-projects.html#paths-absolute-and-relative",
    "title": "3  R Projects",
    "section": "3.1 Paths: absolute and relative",
    "text": "3.1 Paths: absolute and relative\nMost of us live our whole lives without ever having to worry about absolute and relative paths. Unfortunately these are important concepts in programming and you should at least get acquainted with them at some point. I’ll do my best to explain them here, but you can always read this Wikipedia article on this subject for a more in-depth explanation.\nLet’s start with an example: you and I are coworkers and I need you to find a document that I forgot on my desk. Here are my initial instructions:\n\nGo to the lobby of our office building.\nTake the elevator to the Users floor.\nFind the desk with my name on it.\nOpen the second drawer, where I keep all of my documents.\nLook for the folder labeled beautiful-r.\nGrab the document titled projects.qmd.\n\nThis is a pretty decent set of instructions, but they are a bit too detailed; if I needed another document, I wouldn’t want you to go back to the lobby again and start from scratch. Besides, if we moved offices, I’d have to completely change these instructions! Ditto if I left the folder on someone else’s desk.\nBut, since you’re my coworker, what if I assumed you already knew where my beautiful-r folder was? We were at the office the whole week and you saw me working on beautiful-r, I don’t need to explain to you where I left it. In this case, I could give you much shorter instructions:\n\nFind my folder labeled beautiful-r.\nGrab the document titled projects.qmd.\n\nWay simpler, right? As you have probably guessed by now, the first type of instruction represents absolute paths and the second represents relative paths. An absolute path starts at what is called the root directory (i.e. the lobby) and a relative path starts at the working directory (i.e. the folder I was working on)."
  },
  {
    "objectID": "r-projects.html#paths-in-action",
    "href": "r-projects.html#paths-in-action",
    "title": "3  R Projects",
    "section": "3.2 Paths in action",
    "text": "3.2 Paths in action\nIn order to construct an absolute path, you must start from the root directory of your computer. On Linux/MacOS it is simply /, while on Windows it is a drive (usually C:/). This is what the absolute instructions from last section would look like as a path on my MacOS computer:\n\n# Absolute path to projects.qmd\nfs::path_abs(\"projects.qmd\")\n\n/Users/clente/Documents/beautiful-r/projects.qmd\n\n\nOn the other hand, in order to determine the relative path to a file, first you must set your working directory. I’ll explain how to do this in the next section; for now, this is what my current working directory looks like:\n\n# My current working directory\nfs::path_wd()\n\n/Users/clente/Documents/beautiful-r\n\n\nA relative path is simply an absolute path minus your current working directory and any spare slashes. This is what the relative instructions from last section look like as a path:\n\n# Relative path to projects.qmd\nfs::path_rel(\"projects.qmd\")\n\nprojects.qmd\n\n\nArmed with this knowledge, take a look this small slice of the beautiful-r folder on my computer (my current working directory). What is the relative path to renv.qmd? What about rstudio_screenshot.webp?\n.\n├── images\n│   ├── rstudio_screenshot.webp\n│   └── vscode_screenshot.webp\n├── projects.qmd\n└── renv.qmd\nIn both cases, we can ignore anything that is outside of my working directory. The first requested path is simply references.qmd, and the second is images/rstudio_screenshot.webp\nAs you can see, relative paths don’t depend on your computer’s structure, just the structure of the directory you’re working on. If I reference an absolute path in my code and then ask you to run it, it’ll never work as you probably don’t have a /Users/clente/ folder on your machine. This is why we must always use relative paths in our code."
  },
  {
    "objectID": "r-projects.html#setting-up-an-r-project",
    "href": "r-projects.html#setting-up-an-r-project",
    "title": "3  R Projects",
    "section": "3.3 Setting up an R project",
    "text": "3.3 Setting up an R project\nSince relative paths depend on your working directory, we need a way to set it automatically every time we change the project we’re working on. We’re going to do this using R projects.\n\n\n\n\n\n\nImportant\n\n\n\nYou might have heard of a different way to set your working directory called setwd(). If you use this function regularly, I urge you to stop. There are too many ways of breaking setwd(), so using R projects is the way to go.\n\n\nAn R project is just a regular folder with an Rproj sentinel file. Thus, every time you open an R project, its sentinel will set your working directory to be the folder you just opened.\nThere are two ways to create R projects: through RStudio’s built-in menu or with the usethis package. I like the latter method better, but the choice is up to you.\n\n3.3.1 RStudio\nFor the first method, go to File > New Project and select New Directory:\n\n\n\n\n\nThen select New Project:\n\n\n\n\n\nFinally, choose your project’s name and select where it’s going to live:\n\n\n\n\n\nOnce you’re done with this process, RStudio will automatically open your new R project. If you want to switch R projects, simply go to File > Open Project…\n\n\n3.3.2 Other editors\nIf don’t use RStudio or want a reproducible R project setup, then you’ll need usethis::create_project(). This function takes the absolute path to a (non-existing) folder and creates it as an R project.\n\n# Create a project with usethis\nusethis::create_project(\"/Users/clente/Documents/sample\")\n\n\n\n✔ Creating '/Users/clente/Documents/sample/'\n✔ Setting active project to '/Users/clente/Documents/sample'\n✔ Creating 'R/'\n✔ Writing 'sample.Rproj'\n✔ Adding '.Rproj.user' to '.gitignore'\n✔ Setting active project to '<no active project>'\n\n\nAbsolute paths are necessary here because you shouldn’t depend on your current working directory to create another R project’s sentinel file. This can lead to nested projects, a practice that’s strongly discouraged."
  },
  {
    "objectID": "r-projects.html#using-r-projects",
    "href": "r-projects.html#using-r-projects",
    "title": "3  R Projects",
    "section": "3.4 Using R projects",
    "text": "3.4 Using R projects\nWith your new R project active, let’s take a look at what’s inside:\n\n# Directory structure of 'sample'\nfs::dir_tree()\n\n\n\n.\n├── R\n└── sample.Rproj\n\n\nOut of the box, R projects are really bare-bones: they only contain a sentinel file and a folder for R scripts. You’ll probably need at least one more folder to store your data.\n\n# Create 'data-raw' and show directory structure\nusethis::use_data_raw(\"clean\")\nfs::dir_tree()\n\n\n\n.\n├── R\n├── data-raw\n│   └── clean.R\n└── sample.Rproj\n\n\ndata-raw is a classic directory that will contain all data files (CSV, Excel, etc.) and scripts to clean these data. usethis::use_data_raw() automatically creates this directory and a sample cleaning script.\nSuppose I have a mtcars.csv file that needs a scrub. The first step is saving it to data-raw and writing the cleaning script in clean.R. Here is what that file looks like for me:\n\n# Read data\ndf <- readr::read_csv(\"data-raw/mtcars.csv\")\n\n# Clean data\ndf_clean <- dplyr::filter(df, wt < 5)\n\n# Save cleaned data\nreadr::write_csv(df, \"data-raw/mtcars_clean.csv\")\n\n\n\n\nNote how I’m only using relative paths; this way, if I ever share my R project with someone else, they won’t have to deal with broken paths. After running the script, this is what my R project looks like:\n\n# Directory structure after running 'clean.R'\nfs::dir_tree()\n\n\n\n.\n├── R\n├── data-raw\n│   ├── clean.R\n│   ├── mtcars.csv\n│   └── mtcars_clean.csv\n└── sample.Rproj\n\n\nOnce the cleaning process is done, more complex analyses should be kept in the R folder. In any case, scripts will read data-raw/mtcars_clean.csv through its relative path.\nAnd we’re off to the races! Once you start a new class or get assigned to a new project at work, simply create a new R project and use it to keep all pertinent scripts and data. Always use relative paths, store your cleaning scripts on data-raw, and don’t worry about portability ever again."
  },
  {
    "objectID": "git.html#install-first-learn-later",
    "href": "git.html#install-first-learn-later",
    "title": "4  Git",
    "section": "4.1 Install first, learn later",
    "text": "4.1 Install first, learn later\nI suggest you install Git before learning what to do with it. This guarantees that you’ll be able to try everything in this chapter out, so don’t procrastinate. Happy Git has a full chapter about the installation process and corner cases you might run into, but the main points are:\n\nOn Windows and Mac you can grab an installer from the official website.\nOn Linux you can install it from your distro’s package manager. Ubuntu users, for example, can run sudo apt install git on the terminal.\n\nTo check whether you’ve installed Git correctly, verify that you have the Git Bash program (on Windows) or run the following command on your terminal (on Linux/Mac):\n\ngit --version\n\ngit version 2.39.0\n\n\nWith Git properly installed on your computer, register for a GitHub account. It will all make sense later, but this is a cloud platform that stores your Git repositories; it’s a like a Google Drive for code. The registration is fast and using GitHub is free (most of the time), so you don’t have to worry about this step.\nNow you can introduce yourself to Git. This is how we connect our local Git installation with our remote GitHub account. Jump back into R, load the usethis package, and tell Git who you are. In the command below, change NAME to your name and EMAIL to the email address you used when creating your GitHub account:\n\nlibrary(usethis)\nuse_git_config(user.name = \"NAME\", user.email = \"EMAIL\")\ngit_default_branch_configure()"
  },
  {
    "objectID": "git.html#personal-access-token",
    "href": "git.html#personal-access-token",
    "title": "4  Git",
    "section": "4.2 Personal Access Token",
    "text": "4.2 Personal Access Token\nFor your local Git installation to be able to communicate with GitHub, you’ll need to provide it with your “password”. I’m using quotes here because handing out your actual password to a program in your computer would be very insecure. Instead, we’ll use something called a Personal Access Token (PAT).\nA PAT is a long string of characters and numbers that GitHub generates for you and that can be used for authentication instead of your password. There are three main advantages to this approach:\n\nPATs have very limited permissions by default, meaning that, if they end up being leaked, no one can take control of your account. Still, you should never share your PAT with anyone!\nIf someone does get their hands on one of your PATs, you can remotely deactivate them. This is much simpler than changing your password or hunting down the culprit.\nYou can also set an expiration date for each and every PAT you generate, which is the best way to prevent your credentials from leaking by way of old software and hardware you forgot to decommission.\n\nTo generate your first PAT, use usethis::create_github_token():\n\ncreate_github_token()\n\nThis command will open a template on GitHub that you can use to generate a PAT. If you don’t want to learn about the minutiae of access scopes, you can simply change the name of the PAT to something more descriptive (e.g. “Work PC PAT”) and click Create token.\nGitHub will then generate a PAT and allow you to copy it. Make sure to copy it now! For security reasons, you’ll not be able to see your PAT ever again.\nNext, you should store your PAT in a place that Git can access. Simply install the gitcreds package and run gitcreds::gitcreds_set():\n\nlibrary(gitcreds)\ngitcreds_set()\n\n? Enter password or token: YOUR_PAT_GOES_HERE\n-> Adding new credentials...\n-> Removing credentials from cache...\n-> Done.\nIf you accepted usethis’ template, then you’ll need to re-generate this PAT once a month. GitHub will make sure to warn you when a token is close to expiring and even provide you with a nice shortcut to do so, meaning you don’t have to worry about choosing the same access scopes every time. Once you have your new PAT, run gitcreds::gitcreds_set() again and choose Replace these credentials when prompted:\n\ngitcreds_set()\n\n-> Your current credentials for 'https://github.com':\n\n  protocol: https\n  host    : github.com\n  username: PersonalAccessToken\n  password: <-- hidden -->\n\n-> What would you like to do?\n\n1: Keep these credentials\n2: Replace these credentials\n3: See the password / token\n\nSelection: 2\n\n-> Removing current credentials...\n\n? Enter new password or token: YOUR_NEW_PAT_GOES_HERE\n-> Adding new credentials...\n-> Removing credentials from cache...\n-> Done.\nTo make sure your setup is in tip-top shape, you can use either usethis::git_sitrep() or gh::gh_whoami() (just make sure to install the gh package first):\n\ngh::gh_whoami()\n\n{\n  \"name\": \"NAME\",\n  \"login\": \"USERNAME\",\n  \"html_url\": \"https://github.com/USERNAME\",\n  \"scopes\": \"gist, repo, workflow\",\n  \"token\": \"PAT\"\n}"
  },
  {
    "objectID": "git.html#your-first-repository",
    "href": "git.html#your-first-repository",
    "title": "4  Git",
    "section": "4.3 Your first repository",
    "text": "4.3 Your first repository\nA repository (often simply called “repo”) is a folder that uses Git for version control. Now that you have installed Git, created a GitHub account, and introduced yourself, you should be ready to create your first R project that is also a repo.\nFirst, go to https://github.com/new and chose a name for your temporary repo. Mine is going to be called test. Then add a simple description and check the Add a README file box.\n\n\n\n\n\nOnce you’re happy with your repo, click Create repository at the bottom of the page. If you did everything right, you should see a screen like in the image below.\n\n\n\n\n\nNow let’s go back to RStudio. Just like we did in Chapter 3, go to File > New Project, but this time you should select Version Control > Git. Fill the prompt with your GitHub repo’s URL and select a place to create the R project:\n\n\n\n\n\nFinally, click Create Project to finish the process. If this process didn’t work for you, make sure to check out Happy Git’s chapter on troubleshooting. If it has, your RStudio should now have a new Git pane:"
  },
  {
    "objectID": "git.html#using-git-and-github",
    "href": "git.html#using-git-and-github",
    "title": "4  Git",
    "section": "4.4 Using Git and GitHub",
    "text": "4.4 Using Git and GitHub\nNow you should be more than ready to learn how to actually use Git and GitHub."
  },
  {
    "objectID": "patterns.html",
    "href": "patterns.html",
    "title": "Patterns",
    "section": "",
    "text": "Empty."
  },
  {
    "objectID": "packages.html",
    "href": "packages.html",
    "title": "5  Packages",
    "section": "",
    "text": "Empty."
  },
  {
    "objectID": "dependencies.html",
    "href": "dependencies.html",
    "title": "6  Dependencies",
    "section": "",
    "text": "Empty."
  },
  {
    "objectID": "data.html",
    "href": "data.html",
    "title": "7  Data",
    "section": "",
    "text": "Empty."
  },
  {
    "objectID": "testing.html",
    "href": "testing.html",
    "title": "8  Testing",
    "section": "",
    "text": "Empty."
  },
  {
    "objectID": "renv.html",
    "href": "renv.html",
    "title": "9  Renv",
    "section": "",
    "text": "Empty."
  },
  {
    "objectID": "ci-cd.html",
    "href": "ci-cd.html",
    "title": "10  CI/CD",
    "section": "",
    "text": "Empty."
  },
  {
    "objectID": "style.html",
    "href": "style.html",
    "title": "Style",
    "section": "",
    "text": "https://google.github.io/styleguide/go/guide"
  },
  {
    "objectID": "beauty.html",
    "href": "beauty.html",
    "title": "11  Beauty",
    "section": "",
    "text": "Empty."
  },
  {
    "objectID": "pipe.html",
    "href": "pipe.html",
    "title": "12  Pipe",
    "section": "",
    "text": "Empty."
  },
  {
    "objectID": "functions.html",
    "href": "functions.html",
    "title": "13  Functions",
    "section": "",
    "text": "Empty."
  },
  {
    "objectID": "linting.html",
    "href": "linting.html",
    "title": "14  Linting",
    "section": "",
    "text": "Empty."
  },
  {
    "objectID": "shiny.html",
    "href": "shiny.html",
    "title": "15  Shiny",
    "section": "",
    "text": "Empty."
  }
]